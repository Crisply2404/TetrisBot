diff --git a/tetris_ai/Bot.cpp b/tetris_ai/Bot.cpp
index e60bb46..675b96a 100644
--- a/tetris_ai/Bot.cpp
+++ b/tetris_ai/Bot.cpp
@@ -39,6 +39,10 @@ void Bot::startParser() {
             string part1, part2;
             cin >> part1 >> part2;
             outputAction();
+        } else if (command == "action_json") {
+            string part1, part2;
+            cin >> part1 >> part2;
+            outputActionJson();
         } else if (command.size() == 0) {
             // no more commands, exit.
             break;
@@ -122,6 +126,15 @@ void Bot::updateState(const std::string& p1, const std::string& p2, const std::s
         updateField(p3);
     else if(p2=="this_piece_type")
         tetris.m_next[0]=AI::getGem(m_gemMap[p3[0]], 0);
+    else if(p2=="hold") {
+        const char c = p3.empty() ? ' ' : p3[0];
+        if (c == 'N' || c == ' ' || c == '0') tetris.m_pool.m_hold = 0;
+        else tetris.m_pool.m_hold = m_gemMap[c];
+    } else if(p2=="canHold") {
+        // 1=允许 hold；0=不允许（本手已用过 hold）
+        const bool can = (p3 == "1" || p3 == "true" || p3 == "True" || p3 == "YES" || p3 == "yes");
+        tetris.m_hold = can ? 0 : 1;
+    }
     else if(p2=="inAtt")
         m_upcomeAtt=std::stoi(p3);
     else if(p2=="round"){
@@ -373,3 +386,88 @@ void Bot::outputAction() {
     std::cout<<out.str()<<std::endl;    
 
 }
+
+void Bot::outputActionJson() {
+    std::vector<AI::Gem> next;
+    for (int j = 0; j < 5; ++j) // NEXT size
+        next.push_back(tetris.m_next[j]);
+    int deep = AI_TRAINING_DEEP;
+    bool canhold = tetris.hold;
+
+    AI::RunAI(tetris.ai_movs, tetris.ai_movs_flag, tetris.m_ai_param, tetris.m_pool, tetris.m_hold,
+            tetris.m_cur,
+            tetris.m_cur_x, tetris.m_cur_y, next, canhold, m_upcomeAtt,
+            deep, tetris.ai_last_deep, ai.level, 0);
+
+    bool usedHold = false;
+    bool hasLock = false;
+    int lockNum = 0;
+    int lockSpin = 0;
+    int lockX = 0;
+    int lockY = 0;
+
+    if (tetris.alive()) {
+        tetris.m_state = AI::Tetris::STATE_MOVING;
+        while (tetris.ai_movs_flag == -1 && !tetris.ai_movs.movs.empty()) {
+            int mov = tetris.ai_movs.movs[0];
+            tetris.ai_movs.movs.erase(tetris.ai_movs.movs.begin());
+            if (0) ;
+            else if (mov == AI::Moving::MOV_L) tetris.tryXMove(-1);
+            else if (mov == AI::Moving::MOV_R) tetris.tryXMove(1);
+            else if (mov == AI::Moving::MOV_D) tetris.tryYMove(1);
+            else if (mov == AI::Moving::MOV_LSPIN) tetris.trySpin(1);
+            else if (mov == AI::Moving::MOV_RSPIN) tetris.trySpin(3);
+            else if (mov == AI::Moving::MOV_LL) { tetris.tryXXMove(-1); }
+            else if (mov == AI::Moving::MOV_RR) { tetris.tryXXMove(1); }
+            else if (mov == AI::Moving::MOV_DD) tetris.tryYYMove(1);
+            else if (mov == AI::Moving::MOV_DROP) {
+                lockNum = tetris.m_cur.num;
+                lockSpin = tetris.m_cur.spin;
+                tetris.drop();
+                lockX = tetris.m_cur_x;
+                lockY = tetris.m_cur_y;
+                hasLock = true;
+            }
+            else if (mov == AI::Moving::MOV_HOLD) {
+                usedHold = true;
+                tetris.tryHold();
+            } else if (mov == AI::Moving::MOV_SPIN2) {
+                if (AI::spin180Enable()) {
+                    tetris.trySpin180();
+                }
+            } else if (mov == AI::Moving::MOV_REFRESH) {
+                tetris.env_change = 1;
+            }
+        }
+        tetris.clearLines();
+        tetris.m_state = AI::Tetris::STATE_READY;
+    }
+
+    if (!hasLock || lockNum <= 0) {
+        std::cout << "{\"ok\":false,\"error\":\"no_move\"}" << std::endl;
+        return;
+    }
+
+    const AI::Gem &g = AI::getGem(lockNum, lockSpin);
+    std::stringstream out;
+    out << "{\"ok\":true";
+    out << ",\"piece\":\"" << g.getLetter() << "\"";
+    out << ",\"useHold\":" << (usedHold ? "true" : "false");
+    out << ",\"spin\":" << lockSpin;
+    out << ",\"x\":" << lockX;
+    out << ",\"y\":" << lockY;
+    out << ",\"cells\":[";
+    bool first = true;
+    for (int y = 0; y < 4; ++y) {
+        for (int x = 0; x < 4; ++x) {
+            if (g.bitmap[y] & (1 << x)) {
+                if (!first) out << ",";
+                first = false;
+                out << "[" << (lockX + x) << "," << (lockY + y) << "]";
+            }
+        }
+    }
+    out << "]";
+    out << "}";
+    std::cout << out.str() << std::endl;
+}
diff --git a/tetris_ai/Bot.h b/tetris_ai/Bot.h
index 83b5da8..ab32c47 100644
--- a/tetris_ai/Bot.h
+++ b/tetris_ai/Bot.h
@@ -16,6 +16,7 @@ public:
     void startParser();
     void setup();
     void outputAction();
+    void outputActionJson();
     
     struct tetris_ai {
         int style;
@@ -61,4 +62,4 @@ private:
     tetris_ai ai;
 };
 
-#endif	/* BOT_H */
\ No newline at end of file
+#endif	/* BOT_H */
