# 技术设计: CC1 仿 CC2 策略 + 一键重置 + 不同步兜底

## 技术方案

### 核心技术
- Chrome Extension（MV3）：popup/options/content script/service worker
- 页面内 Hook：在 MAIN 世界里抓 tetr.io 的 `ejectState()` / `getHolderData()`（以及 PIXI 自动对齐）
- 引擎：
  - CC2：本机服务（可选）
  - CC1：插件内 WASM（兜底）

### 实现要点

#### 1) CC1「仿 CC2 默认权重」策略（只在 CC1 生效）
**关键点：我们没法改 CC1 引擎内部的评分函数**，所以采取“后处理”：
1. 让 CC1 继续按原样吐出一串候选落点（它本来就会给很多候选）
2. 我们把候选里靠前的 N 个（例如 30~40 个）拿出来
3. 对每个候选做一次“快速模拟”：把这个块放到当前棋盘上、算清几行、算洞/高度/转折/井深等特征
4. 用 CC2 的 `default.json`（freestyle_weights）那套权重给候选打分
5. 选分最高的作为最终要画出来的落点

说明：
- 这只是让 CC1 的“最终显示落点”更接近 CC2 风格，不保证完全一致。
- 这套策略只作用于 CC1；当你实际在用 CC2 时，不额外重排（避免重复“二次干预”）。

#### 2) “落点还能往下掉”= 强不同步信号
在 content script 收到引擎返回落点后，我们会把 TBP 坐标换成棋盘格坐标。
新增一条检查：
- 如果“整块往下挪一格”仍然不撞墙、不压到已有方块，也不越界 → 说明这不是最终落点（悬空）
- 立刻当成不同步：清空这次建议、reset 引擎（CC1/CC2）、下一轮重新算

#### 3) 手动 Reset 按钮（清异常缓存 + 重新捕获 API）
在 popup（必要时也可在详情页）增加一个按钮，例如：
- “强制重置（清缓存）”

点击后做三件事（按顺序）：
1. **清扩展内存缓存**：包括“短队列/长队列”两套记忆、上一手增量同步记忆、旧建议/旧 debug
2. **重置引擎**：发 `TBP_CC_RESET` 给后台（同时 reset CC1 & CC2）
3. **让页面重新抓局面**：给 pageHook 发一个新消息（例如 `TBP_RESET_CAPTURE`），让它清掉已捕获的 `__tbpGameApi` 并重新安装 Map tap，从而能在切模式后重新捕获新的 API

这样可以直接解决“切模式后还在用旧 API → 状态停留在旧局面”的顽固问题。

#### 4) 自动兜底：长时间没收到新状态就清空
补一个“心跳超时”：
- 如果 content 侧超过一段时间（例如 2~3 秒）没收到新的 `TBP_STATE`，就把当前画面清空并提示“状态卡住了，点一下重置或刷新页面”。

## 架构决策 ADR
### ADR-001: CC1 采用“候选后处理重排”而非复刻 CC2
**上下文:** 你希望减少对 CC2 服务的依赖，但 CC1（WASM）不方便大改内部评分。
**决策:** 对 CC1 的候选落点做“仿 CC2 权重”的二次重排，作为可选策略。
**理由:** 实现成本低、可开关、对现有架构侵入小。
**替代方案:** 直接在扩展里完整复刻 CC2 的搜索/评估 → 拒绝原因: 复杂度/性能/维护成本过高。
**影响:** CC1 在某些局面下会更像对战风格，但仍不保证等同 CC2。

## 安全与性能
- **安全:** reset/重置只作用于本地扩展状态，不触碰账号/网络敏感数据。
- **性能:** CC1 二次重排只对前 N 个候选做，避免把弹窗/游戏页面卡住；必要时可把 N 做成隐藏配置。

## 测试与部署
- **测试:** 以手动验证为主：
  - CC1 + cc2Weights 策略是否能跑出稳定落点
  - 触发“悬空落点”时是否会自动 reset 并恢复
  - 切模式/退局后是否还能正确刷新局面；手动 reset 是否立刻恢复
- **部署:** 重新加载扩展即可；CC2 仍是可选，本地服务不开也能用 CC1。
