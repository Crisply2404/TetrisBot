# 模块：engine（离线“最佳摆放”计算）

## 目的
给出“当前块怎么放更好”的建议，并支持在详情页给出“当前块 + Next5”的完整摆法。

## 模块概述
- **职责:** 基于 GameState 输出 Suggestion（实时）与 Plan（详情页用）
- **状态:** ✅叠加提示已接入 Cold Clear v1；⚠️详情页完整摆法仍是占位规划
- **最后更新:** 2026-02-11

## 现状（现在代码怎么做的）
相关代码在：
- `extension/content/content.js`：从 state 拿实时局面，向后台请求“当前块推荐落点”，并把结果画到叠加层
- `extension/offscreen/offscreen.js`：offscreen 文档里跑 Cold Clear（WASM/Worker），按 TBP 协议给建议
- `extension/engine/coldClearTbpClient.js`：TBP 客户端（rules/start/suggest，拿 suggestion 的落点）
- `extension/shared/tetris-sim.js`：兜底用的简化引擎（当 Cold Clear 不可用时回退）

当前实现分两层：
- **实时叠加层（当前块建议）**：只走 Cold Clear v1（WASM，离线）。如果 cold-clear 失败，就会“暂时不显示建议”，而不是回退到另一套逻辑（避免你看到两套结果对不上）。
- **详情页（实时，步骤列表）**：目前还是用简化规划（beam search）来给出「当前块 + Next5」步骤（后续再升级成“也用 Cold Clear 或更强引擎来生成完整计划”）。

注意：
- 如果浏览器不支持/禁用了 offscreen，或 cold-clear worker 启动失败，实时建议会暂时拿不到；弹窗（调试模式）会显示 `cold-clear：...` 的原因。
- **7-bag 预判（已增强）**：默认会读取更长的块序，并按 7-bag 的“分袋边界”把 next 队列喂给 cold-clear（6→12→…→6 循环），帮它做更远的规划（不只 Next5）。你也可以在设置里把它关掉做对比（会退回只看 Next5）。
- **稳定性修复（关键）**：短队列（current+next5）时，`bag_state` 现在只从“队列末尾”反推，避免跨袋重复把 cold-clear 喂到不可能的 randomizer 状态里，导致 `RuntimeError: unreachable` 崩溃回退。
- **Zen 撤回/重开（暂不防抖）**：如果检测到帧号倒退（时间回退），目前会立即 reset cold-clear，避免带着旧局面继续算导致串状态/超时（你如果想恢复“防抖 + 限流”，我们再加回来）。
- **对战更像“会打旋转”**：对战模式下，如果 cold-clear 给了多个候选落点，我们会优先选出能打 T-Spin/Spin 的落点（取决于设置里的“对战旋转判定”），避免死板地永远只拿第 1 名导致观感像“纯消行”。
- **候选落点为什么会有很多个？它的“推荐理由”是什么？**  
  cold-clear 会返回一个候选列表（按它自己的内部评分从更推荐到更不推荐排序）。我们能直接看到的是：排行、落点、是否 spin、是否需要 hold；但**拿不到它内部每个候选的具体分数/权重**。所以你看到的“推荐理由”本质上就是：它那套黑盒评分觉得这个更好。我们目前做的对战预设，就是在候选里做一个“更像对战”的二次选择（例如优先挑有 T-Spin 的候选），而不是完全照第 1 名照搬。
- **为什么 undo 回到同一局面，cc 有时会给不同建议？**  
  为了符合你想要的“一致性”，我们加了一个很直观的做法：**同一个局面+同一串 next（喂给 cc 的块序）+同一套设置，只要算过一次，就直接复用这次结果**。这样 undo 回去就不会“又换了一种建议”。  
  （这不是说 cc 一定随机，而是我们不想让你被“重复算出的不同答案”干扰。）  
- **为什么 Hold 会出现“前后矛盾”？**  
  tetr.io 的规则是：**每个块最多 Hold 一次**（Hold 后直到落地前不能再 Hold）。以前我们没把这条规则告诉引擎，所以会出现“刚 Hold 完又建议再 Hold 一次”的假矛盾。现在我们会推断 `canHold` 并传给引擎，避免给出这种不合法建议。

## 规范

### 需求: 两套目标（40L vs 对战）
**模块:** engine  
同样是“最优”，40L 和对战的“最优”不一样：
- **40L:** 更像“把地整平、别挖坑、尽快清行”
- **对战:** 更像“别死 + 能打出 T-spin / 连段 / 清垃圾的空间”

#### 场景: 40L 预设
- 预期结果：更偏向平整与效率（减少洞、减少高度、利于清行）

#### 场景: 对战预设（先做 T-spin 风格）
- 预期结果：更偏向 T-spin 机会与安全（留出垃圾通道、避免高堆）

### 需求: Next5 + 7-bag 推断（增强）
**模块:** engine  
只看 Next5 可能不够；7-bag 意味着“接下来没出现过的块一定会在这袋里出现”。  
目前我们用的是更“直接”的做法（不靠采样）：
- 默认只喂 **current + next5**（长度 6，启动更快）
- 一旦 next5 已经“跨袋”（也就是 next5 里已经出现下一袋的块），就把 **旧袋剩余（含 current）+ 下一袋完整 7 个** 一起喂给 cold-clear  
  - 这会让喂进去的序列长度在一袋的后半段变长（6 → 12），然后随着旧袋被消耗逐步变短（12 → … → 8），到新袋开始又回到 6
- 这套逻辑在 `extension/engine/sevenBagQueue.js` 里（专门负责“怎么算队列长度/从 next 里截哪一段”）

## 依赖
- cold-clear（参考实现/未来接入的强力引擎）
