# 模块：engine（离线“最佳摆放”计算）

## 目的
给出“当前块怎么放更好”的建议，并支持在详情页给出“当前块 + Next5”的完整摆法。

## 模块概述
- **职责:** 基于 GameState 输出 Suggestion（实时）与 Plan（详情页用）
- **状态:** ✅叠加提示默认优先走 Cold Clear 2（本地服务）；✅连不上会自动回退 Cold Clear 1（插件内 WASM）；⚠️详情页“后续步骤”仍是简化规划（先够用）
- **最后更新:** 2026-02-15

## 现状（现在代码怎么做的）
相关代码在：
- `extension/content/content.js`：从 state 拿实时局面，向后台请求“当前块推荐落点”，并把结果画到叠加层
- `extension/sw.js`：引擎路由（优先本地 CC2；失败自动回退 CC1）
- `cc2-server/server.js`：本地 CC2 服务（HTTP），内部用 stdin/stdout 驱动 `cold-clear-2`（TBP）
- `extension/offscreen/offscreen.js`：CC1 路线：offscreen 文档里跑 Cold Clear v1（WASM/Worker）
- `extension/engine/coldClearTbpClient.js`：CC1 的 TBP 客户端（rules/start/suggest，拿 suggestion 的落点）
- `extension/shared/tetris-sim.js`：目前用于**详情页的“后续步骤预览”**（不是实时叠加层的兜底）
- `extension/engine/sevenBagQueue.js`：7-bag 变长队列（6→12→…→6）构造

当前实现分两层：
- **实时叠加层（当前块建议）**：
  - 默认优先走 **Cold Clear 2（CC2，本地服务）**：更强、更像对战。
  - 如果扩展连不上本地 CC2，会自动回退到 **Cold Clear 1（CC1，WASM，离线）**。
  - 如果两边都失败：就会“暂时不显示建议”，并在弹窗/详情页里写出原因，避免你看到两套结果对不上。
- **详情页（实时，步骤列表）**：
  - “实时落点”：和叠加层同一份结果（以详情页为准）
  - “后续步骤”：目前还是简化规划（beam search）给出「当前块 + Next5」的预览（后续再升级成“也用 Cold Clear 或更强引擎生成完整计划”）

注意：
- CC2 需要你本机先启动服务：见 `cc2-server/README.md`。
- 如果浏览器不支持/禁用了 offscreen，或 CC1 的 cold-clear worker 启动失败：兜底也可能跑不起来；弹窗会显示 `cold-clear：...` 的原因。
- **7-bag 预判（已增强）**：默认会读取更长的块序，并按 7-bag 的“分袋边界”把 next 队列喂给 cold-clear（6→12→…→6 循环），帮它做更远的规划（不只 Next5）。你也可以在设置里把它关掉做对比（会退回只看 Next5）。
- **稳定性修复（关键）**：短队列（current+next5）时，`bag_state` 现在只从“队列末尾”反推，避免跨袋重复把 cold-clear 喂到不可能的 randomizer 状态里，导致 `RuntimeError: unreachable` 崩溃回退。
- **Zen 撤回/重开（暂不防抖）**：如果检测到帧号倒退（时间回退），目前会立即 reset cold-clear，避免带着旧局面继续算导致串状态/超时（你如果想恢复“防抖 + 限流”，我们再加回来）。
- **策略到底是谁做？**
  - **CC2：**它自己内部就带“对战倾向”的评分（我们按 TBP 规范直接取第 1 名），所以**不需要我们前端再写一套“策略”**。
  - **CC1（兜底）：**它会返回多个候选，我们才会用设置项决定“最终画哪一个”（严格第 1 名 / 偏好旋转 / 实验伤害重排）。
  - **CC1 也想更像 CC2：**新增一个仅影响 CC1 的策略：`仿 CC2 默认权重（cc2Weights）`。做法是：拿 CC1 返回的候选前 N 个，在前端快速模拟落点后按 CC2 的 `freestyle_weights` 思路打分重排，再选分数最高的那个。这样你不开本地 CC2 时，CC1 也能更“像对战”一点（但仍不保证完全等价）。
- **候选落点为什么会有很多个？它的“推荐理由”是什么？**  
  cold-clear 会返回一个候选列表（按它自己的内部评分从更推荐到更不推荐排序）。我们能直接看到的是：排行、落点、是否 spin、是否需要 hold；但**拿不到它内部每个候选的具体分数/权重**。所以你看到的“推荐理由”本质上就是：它那套黑盒评分觉得这个更好。我们目前做的对战预设，就是在候选里做一个“更像对战”的二次选择（例如优先挑有 T-Spin 的候选），而不是完全照第 1 名照搬。

- **对战上下文（combo / B2B）**：
  TBP 的 `start` 消息支持 `combo` 和 `back_to_back`。我们现在会尽量从 `ejectState()` 提取这两个值并喂给 cold-clear（提取不到就用默认值）。这样它至少“知道你现在是不是在连击/B2B中”，不会像完全不知道上下文那样出招。
- **为什么 undo 回到同一局面，cc 有时会给不同建议？**  
  为了符合你想要的“一致性”，我们加了一个很直观的做法：**同一个局面+同一串 next（喂给 cc 的块序）+同一套设置，只要算过一次，就直接复用这次结果**。这样 undo 回去就不会“又换了一种建议”。  
  （这不是说 cc 一定随机，而是我们不想让你被“重复算出的不同答案”干扰。）  
- **为什么 Hold 会出现“前后矛盾”？**  
  tetr.io 的规则是：**每个块最多 Hold 一次**（Hold 后直到落地前不能再 Hold）。以前我们没把这条规则告诉引擎，所以会出现“刚 Hold 完又建议再 Hold 一次”的假矛盾。现在我们会推断 `canHold` 并传给引擎，避免给出这种不合法建议。

- **悬空落点（还能往下掉）怎么处理？**  
  如果检测到“建议落点整体还能往下掉 1 格”，我们会把它视为不同步：先清空建议，并**自动 reset 引擎一次**等待下一帧重算；同一个局面最多自动重置 1 次，避免死循环。仍异常就会提示你点「强制重置（清缓存）」或刷新页面。

## 规范

### 需求: 两套目标（40L vs 对战）
**模块:** engine  
同样是“最优”，40L 和对战的“最优”不一样：
- **40L:** 更像“把地整平、别挖坑、尽快清行”
- **对战:** 更像“别死 + 能打出 T-spin / 连段 / 清垃圾的空间”

#### 场景: 40L 预设
- 预期结果：更偏向平整与效率（减少洞、减少高度、利于清行）

#### 场景: 对战预设（先做 T-spin 风格）
- 预期结果：更偏向 T-spin 机会与安全（留出垃圾通道、避免高堆）

### 需求: Next5 + 7-bag 推断（增强）
**模块:** engine  
只看 Next5 可能不够；7-bag 意味着“接下来没出现过的块一定会在这袋里出现”。  
目前我们用的是更“直接”的做法（不靠采样）：
- 默认只喂 **current + next5**（长度 6，启动更快）
- 一旦 next5 已经“跨袋”（也就是 next5 里已经出现下一袋的块），就把 **旧袋剩余（含 current）+ 下一袋完整 7 个** 一起喂给 cold-clear  
  - 这会让喂进去的序列长度在一袋的后半段变长（6 → 12），然后随着旧袋被消耗逐步变短（12 → … → 8），到新袋开始又回到 6
- 这套逻辑在 `extension/engine/sevenBagQueue.js` 里（专门负责“怎么算队列长度/从 next 里截哪一段”）

## 依赖
- cold-clear（参考实现/未来接入的强力引擎）

## 参考（对战伤害规则）
> 说明：tetr.io 的规则可能会更新；我们把“按伤害估算重排”标记为实验，就是为了避免把它当成绝对真理。

- TETR.IO 规则整理（含 B2B/连击/伤害等）：`https://tetris.wiki/TETR.IO`
- 伤害表对照（用于交叉验证）：`https://tetris.johnbeak.cz/`
